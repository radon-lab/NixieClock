//перечисления системных звуков
enum {
  SOUND_TEST_SPEAKER, //звук проверки
  SOUND_PASS_ERROR, //звук ошибки ввода пароля
  SOUND_RESET_SETTINGS, //звук сброса настроек
  SOUND_ALARM_DISABLE, //звук отключения будильника
  SOUND_ALARM_WAIT, //звук ожидания будильника
  SOUND_TIMER_WARN, //звук окончания таймера
  SOUND_HOUR //звук смены часа
};

//перечисления режимов воспроизведения мелодий
enum {
  REPLAY_STOP, //остановить воспроизведение
  REPLAY_ONCE, //проиграть один раз
  REPLAY_CYCLE //проиграть по кругу
};

//переменные работы со звуками
struct soundData {
  uint8_t replay; //флаг повтора мелодии
  uint16_t semp; //текущий семпл мелодии
  uint16_t link; //ссылка на мелодию
  uint16_t size; //количество семплов мелодии
} sound;
volatile uint16_t buzz_cnt_puls; //счетчик циклов длительности
volatile uint16_t buzz_cnt_time; //счетчик циклов полуволны
uint16_t buzz_time; //циклы полуволны для работы пищалки

//-----------------------Прерывание сигнала для пищалки-------------------------
#if !PLAYER_TYPE
ISR(TIMER2_COMPB_vect) //прерывание сигнала для пищалки
{
  if (!buzz_cnt_time) { //если циклы полуволны кончились
    BUZZ_INV; //инвертируем бузер
    buzz_cnt_time = buzz_time; //устанавливаем циклы полуволны
    if (!--buzz_cnt_puls) { //считаем циклы времени работы бузера
      BUZZ_OFF; //если циклы кончились, выключаем бузер
      TIMSK2 &= ~(0x01 << OCIE2B); //выключаем таймер
    }
  }
  if (buzz_cnt_time > 255) buzz_cnt_time -= 255; //считаем циклы полуволны
  else if (buzz_cnt_time) { //если остался хвост
    OCR2B += buzz_cnt_time; //устанавливаем хвост
    buzz_cnt_time = 0; //сбрасываем счетчик циклов полуволны
  }
}
#endif
//--------------------------------Генерация частот бузера----------------------------------------------
void buzz_pulse(uint16_t freq, uint16_t time) //генерация частоты бузера (частота 10..10000, длительность мс.)
{
  TIMSK2 &= ~(0x01 << OCIE2B); //выключаем таймер
  BUZZ_OFF; //выключаем бузер
  buzz_cnt_time = 0; //сбросили счетчик
  buzz_cnt_puls = CONSTRAIN(((uint32_t)freq * (uint32_t)time) / 500, 2, 65534) & 0xFFFE; //пересчитываем частоту и время в циклы таймера
  buzz_time = (1000000 / freq); //пересчитываем частоту в циклы полуволны
  OCR2B = 255; //устанавливаем COMB в начало
  TIFR2 |= (0x01 << OCF2B); //сбрасываем флаг прерывания
  TIMSK2 |= (0x01 << OCIE2B); //запускаем таймер
}
//----------------------------Запуск воспроизведения мелодии---------------------------------------------
void melodyPlay(uint8_t melody, uint16_t link, uint8_t replay) //запуск воспроизведения мелодии
{
  sound.semp = 0; //сбросили позицию семпла
  sound.replay = replay; //установили повтор
  sound.link = pgm_read_word(link + (melody << 2)); //установили ссылку
  sound.size = pgm_read_word(link + (melody << 2) + 2); //установили размер
  _timer_ms[TMR_PLAYER] = 0; //сбросили таймер
}
//---------------------------Остановка воспроизведения мелодии-------------------------------------------
void melodyStop(void) //остановка воспроизведения мелодии
{
  sound.replay = REPLAY_STOP; //сбросили воспроизведение
  _timer_ms[TMR_PLAYER] = 0; //сбросили таймер
}
//--------------------------------Воспроизведение мелодии-----------------------------------------------
void melodyUpdate(void) //воспроизведение мелодии
{
  if (sound.replay && !_timer_ms[TMR_PLAYER]) { //если пришло время
    buzz_pulse(pgm_read_word(sound.link + sound.semp), pgm_read_word(sound.link + sound.semp + 2)); //запускаем звук с задоной частотой и временем
    _timer_ms[TMR_PLAYER] = pgm_read_word(sound.link + sound.semp + 4); //устанавливаем паузу перед воспроизведением нового звука
    if ((sound.semp += 6) >= sound.size) { //переключаем на следующий семпл
      if (sound.replay == REPLAY_ONCE) melodyStop(); //если повтор выключен то остановка воспроизведения мелодии
      sound.semp = 0; //сбросили семпл
    }
  }
}
